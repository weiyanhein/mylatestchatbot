# backend/models.py

from typing import List, Literal, Optional, TypedDict, Dict, Any
from pydantic import BaseModel, Field
from langchain_core.messages import BaseMessage # Important for chat_history type

# --- Pydantic Models for API Responses ---
class RecommendedProductForAPI(BaseModel):
    name: str = Field(description="The name of the recommended product.")
    brand: str = Field(description="The brand of the recommended product.")
    product_id: str = Field(description="The unique ID of the product.")
    image_filename: str = Field(description="The filename of the product image (e.g., prod_001.jpg).")
    image_url: str = Field(description="The full URL to the product image, hosted by the API.")
    reasoning: str = Field(description="A brief explanation why this product is suitable for the user's needs, based on the query, benefits, concerns, or key ingredients.")
    product_type: Optional[str] = Field(None, description="The type of the product (e.g., serum, cleanser, moisturizer).")
    ingredients: Optional[List[str]] = Field(None, description="Key ingredients of the product.")
    benefits: Optional[List[str]] = Field(None, description="Main benefits provided by the product.")
    usage: Optional[str] = Field(None, description="Instructions on how to use the product.")

class SkinAnalysisResult(BaseModel):
    skin_type: str = Field(description="The detected skin type (e.g., 'oily', 'dry', 'combination', 'normal', 'sensitive').")
    concerns: List[str] = Field(default_factory=list, description="A list of detected skin concerns (e.g., 'acne', 'redness', 'dark spots').")
    recommendations: str = Field(description="General advice or immediate next steps based on the analysis.")

class ChatResponse(BaseModel):
    response: str = Field(description="The natural language response from the chatbot.")
    chat_history: List[Dict[str, str]] = Field(description="A simplified history of the conversation for the frontend, with 'human' or 'ai' keys.")
    product_recommendation: Optional[List[RecommendedProductForAPI]] = Field(None, description="A list of product recommendations, if any, with full details for the API.")
    skin_analysis_result: Optional[SkinAnalysisResult] = Field(None, description="The result of a skin analysis, if performed and relevant.")

# --- Pydantic Model for API Requests ---
class ChatRequest(BaseModel):
    user_message: str = Field(description="The current message from the user.")
    chat_history: Optional[List[Dict[str, str]]] = Field(None, description="A simplified history of previous turns in the conversation.")
    skin_analysis_result: Optional[SkinAnalysisResult] = Field(None, description="Previously obtained skin analysis result, passed back from the frontend for context.")

class SkinAnalysisRequest(BaseModel):
    image_path: str = Field(description="Local path to the uploaded image for analysis. (Note: This is illustrative, actual image upload is via FastAPI's UploadFile).")

# --- Pydantic Model for LLM Output (Internal to Agent - strictly for JSON parsing) ---
class LLMRecommendedProduct(BaseModel):
    name: str = Field(description="The name of the recommended product.")
    brand: str = Field(description="The brand of the recommended product.")
    product_id: str = Field(description="The unique ID of the product, used to fetch full details.")
    image_filename: str = Field(description="The filename of the product image (e.g., prod_001.jpg), used for constructing the image URL.")
    reasoning: str = Field(description="A concise reason why this specific product is recommended for the user's query.")
    product_type: Optional[str] = Field(None, description="The type of the product (e.g., serum, cleanser).")
    ingredients: Optional[List[str]] = Field(None, description="Key ingredients of the product.")
    benefits: Optional[List[str]] = Field(None, description="Main benefits of the product.")
    usage: Optional[str] = Field(None, description="Brief instructions on how to use the product.")

class ProductRecommendationResponse(BaseModel):
    recommendations: List[LLMRecommendedProduct] = Field(description="A list of recommended products based on the user's query and provided product information.")
    general_message: str = Field(description="A friendly, concise general message introducing the recommendations to the user.")

# --- LangChain Graph State Definition (TypedDict) ---
class ChatbotState(TypedDict):
    user_message: str
    chat_history: List[BaseMessage] # Internal chat history uses LangChain BaseMessage objects (HumanMessage, AIMessage)
    intent: str # Set by intent_classifier (e.g., "product_query", "guideline_query")
    next_node: str # Set by intent_classifier, directs graph flow to the next agent
    response: str # The final text response generated by an agent
    product_recommendation_data: Optional[List[RecommendedProductForAPI]] # Final processed product data for API response
    skin_analysis_result_data: Optional[SkinAnalysisResult] # Internal skin analysis result data, passed between agents
    retrieved_docs: Optional[List[Dict[str, Any]]] # Contextual documents retrieved from vector stores (e.g., knowledge base, product info)
    comparison_products: Optional[List[Dict[str, Any]]] # Data for product comparison (if implemented)
    # Add other state variables as needed by new agents or for cross-agent communication